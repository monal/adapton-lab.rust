//! For more information and instructions, see the [Adapton Lab
//! README](https://github.com/cuplv/adapton-lab.rust).
#![feature(box_patterns)]
#![feature(field_init_shorthand)]
//#![feature(rustc_private)]
//#![feature(custom_derive)]

//extern crate serialize;
//extern crate csv;
extern crate rand;

#[macro_use]
extern crate clap;

#[macro_use]
extern crate adapton;

extern crate adapton_lab;

//extern crate iodyn;

/// Defines lab parameters `LabParams` and `LabDef`, the parameters
/// for running the test diagram from the [Adapton Lab
/// README](https://github.com/cuplv/adapton-lab.rust).
//pub mod labdef;

/// This module of Adapton Lab extends Adapton's existing reflection
/// (see `adapton::engine::reflect`) with further reflections.  In
/// particular, we produce HTML output structure, for human user
/// interaction and consumption.
//pub mod labviz;

/// **Generically implements** the test diagram in the [Adapton Lab
/// README](https://github.com/cuplv/adapton-lab.rust).
//pub mod labrun;

/// Provides **concrete instances** of the test diagram from the
/// [Adapton Lab README](https://github.com/cuplv/adapton-lab.rust).
//pub mod catalog;

/// Provides **concrete instances** of the test diagram from the
/// [Adapton Lab README](https://github.com/cuplv/adapton-lab.rust).
pub mod catalog;

use labdef::*;
use adapton_lab::{labdef,labviz};
use adapton::engine::reflect::string_of_name;
use adapton::engine::name_of_string;

// fn csv_of_runtimes(path:&str, samples: Vec<Sample>) {
//   let path = Path::new(path);
//   let mut writer = csv::Writer::from_file(path).unwrap();
//   for r in samples.into_iter() {
//     //println!("{:?}",r);
//     //writer.encode(r).ok().expect("CSV writer error");
//   }
// }

fn lab_params_defaults() -> LabParams {
  
  let do_reflect = true;
  //let do_reflect = false;
  
  return LabParams {
    sample_params: SampleParams {
      input_seeds: vec![0],
      generate_params: GenerateParams {
        size: 8,
        //size: 16,
        //size: 32,
        //size: 64,
        //size: 256,
        //size: 1024,
        //size: 10000,
        //size: 20000,
        //size: 50000,
        // size: 100000,
        //size: 200000,
        gauge:1,
        nominal_strategy: NominalStrategy::Regular,
      },
      demand: 6,
      validate_output: true,
      change_batch_size: 1,
      reflect_dcg: do_reflect,
      reflect_trace: do_reflect,
    },
    change_batch_loopc:10,
  }
}

// TODO -- Put these implementations into a 'catalog' module.

fn run_lab(params:&LabParams, lab:&Box<Lab>) -> LabResults {
  println!("Running lab: {}", string_of_name( &lab.name() ) );
  let result = lab.run(params);
  labviz::write_lab_results(params, lab, &result);
  result
}

fn run_all_labs(params:LabParams) {
  let labs  = catalog::all_labs();
  let mut results = vec![];
  for lab in labs.iter() {
    let result = run_lab(&params, &lab);
    results.push(result);
  }  
  labviz::write_lab_results_summary(&params, &labs, &results);
}

#[test]
fn test_all() { run_all_labs(lab_params_defaults()) }

fn main2() { 
  let args = clap::App::new("adapton-lab")
    .version("0.0.1")
    .author("Matthew A. Hammer <matthew.hammer@colorado.edu> and the Adapton Team")      
    .about("Adapton Lab: Systematic laboratory environment for Adapton in Rust.

    Permits the command-line experimenter to define visualizations and
    performance evaluations of Adapton, including its standard
    library, and (eventually) other applications that use it.

    For developers, Adapton Lab consists of a generic lab definition
    (the `Lab` trait), and a parameterized structure (the `LabDef`
    struct) that uses several abstract parameters that define roles
    for the 'Editor' and the 'Archivist'.

    For both developers and experimenters, Adapton Lab includes a
    catalog of instances of these abstract definitions. ")

    .args_from_usage("\
    --run-viz     'run lab catalog for visualization: small input size, with reflection'
    --run-bench   'run lab catalog for benchmarking: large input size, without reflection'
    -L,  --lab=[labname]       'determines the Editor and the Archivist, from the lab catalog'
    -s,  --size=[size]         'for the Editor: the initial input size generated by the Editor.'
    -a,  --artfreq=[artfreq]   'for the Editor: the frequency of articulations, measured in non-nominal constructors.'
    -b,  --batch=[batch]       'for the Editor: the number of edits that the Editor performs at once.'
    -l,  --loopc=[loopc]       'for the Editor and Archivist: the loop count of edit-and-compute.'
    -d,  --demand=[demand]     'for the Archivist: the number of output elements to demand; only relevant for lazy Archivists.'
         --validate=[validate] 'a boolean indicating whether to validate the output; the default is true.'"
    ).get_matches();

  // Start with the defaults, changing them according to the command-line arguments:
  let mut params = lab_params_defaults();
  
  if args.is_present("viz") && args.is_present("bench") {
    panic!("Currently, I can only do _one_ of --run-viz or --run-bench, not both.");
  } else if args.is_present("run-viz") {
    params.sample_params.generate_params.size = 8;
    params.sample_params.reflect_dcg   = true;
    params.sample_params.reflect_trace = true;
  } else if args.is_present("run-bench") {
    params.sample_params.generate_params.size = 100000;
    params.sample_params.reflect_dcg   = false;
    params.sample_params.reflect_trace = false;    
  } else { }
  ;
  {
    let s = params.sample_params.generate_params.size ;
    params.sample_params.generate_params.size = 
      value_t!(args.value_of("size"),usize).unwrap_or( s );
  };
  {
    let a = params.sample_params.generate_params.gauge ;
    params.sample_params.generate_params.gauge = 
      value_t!(args.value_of("artfreq"),usize).unwrap_or( a );
  };
  {
    let b = params.sample_params.change_batch_size ;
    params.sample_params.change_batch_size = 
      value_t!(args.value_of("batch"),usize).unwrap_or( b );
  };
  {
    let d = params.sample_params.demand ;
    params.sample_params.demand = 
      value_t!(args.value_of("demand"),usize).unwrap_or( d );
  };
  {
    let l = params.change_batch_loopc ;
    params.change_batch_loopc = 
      value_t!(args.value_of("loopc"),usize).unwrap_or( l );
  };
  // TODO check --validate


  let mut run_one_lab = false;
  {
    let l = value_t!(args.value_of("labname"),String).unwrap_or( String::from("") );
    if l.len() > 0 {
      for lab in catalog::all_labs() {
        if lab.name() == name_of_string(l.clone()) {
          run_one_lab = true;
          println!("Lab params:\n\t{:?}", params );
          let _ = run_lab( &params, &lab );        
        }
      };
      if ! run_one_lab {
        println!("Error: couldn't find the lab `{}`.", l);
        println!("Hint: Here's the full lab catalog:");
        for lab in catalog::all_labs() {
          println!(" - {:32}: {}", string_of_name (&lab.name()), 
                   match *lab.url() { Some(ref s) => s, None => "" } );
        }
        panic!("Error: couldn't find the lab `{}`.", l);
      }
    } else { }
  }
  if ! run_one_lab {
    println!("Lab params:\n\t{:?}", params );
    run_all_labs(params) 
  }
}

fn main () {
  use std::thread;
  let child =
    thread::Builder::new().stack_size(64 * 1024 * 1024).spawn(move || { 
      main2()
    });
  let _ = child.unwrap().join();
}
